#![allow(unused)]

//! Uploads vertex data to GPU buffers and draws them using a render pipeline.
//!
//! This module takes geometry generated by the renderer (as `Vertex` structs)
//! and submits it for rendering via a WGPU command encoder.

use crate::geometry::Vertex;
use wgpu::{Buffer, BufferUsages, Device, RenderPass, util::DeviceExt};

/// Wraps a GPU vertex buffer prepared for rendering.
pub struct VertexBuffer {
    pub buffer: Buffer,
    pub vertex_count: u32,
}

impl VertexBuffer {
    /// Uploads vertex data to a GPU buffer.
    ///
    /// The data must be tightly packed (no padding) and match the layout
    /// expected by the shader (`vec2<f32>` at location 0).
    pub fn from_vertices(device: &Device, vertices: &[Vertex]) -> Self {
        let data = bytemuck::cast_slice(vertices);
        let buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Ardent Vertex Buffer"),
            contents: data,
            usage: BufferUsages::VERTEX,
        });

        Self {
            buffer,
            vertex_count: vertices.len() as u32,
        }
    }

    /// Issues a draw call for the given vertex buffer.
    ///
    /// This must be called within an active render pass that has already
    /// set the render pipeline.
    pub fn draw<'a>(&'a self, pass: &mut RenderPass<'a>) {
        pass.set_vertex_buffer(0, self.buffer.slice(..));
        pass.draw(0..self.vertex_count, 0..1);
    }
}
